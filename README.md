# Arbor
*Note: this repo is likely to move once this project has a confirmed name. "Arbor" is just the current working name*

## Overview
Arbor is intended to allow the collection and management of 3 distinct data types in the context of a research study: survey, genomic, and medical records.
Pre-registration screeners, registration, consent forms, surveys, genomic kit testing, and medical records retrieval can all be configured from inside the admin interface.
the participant-facing portal then displays a home page and the configured content to study participants

### Structure

#### Core
Contains base POJO data models, DAOs, and services.  The core is responsible for postgres data persistence,
and so this is also where liquibase lives.  Running the CoreCliApp will do nothing except run liquibase

#### Populate
Contains functionality for populating entities from files, as well as basic seed data.  this includes populate
DTOs, and populate services.  the PopulateCliApp can be used to populate specific entities from files via command-line

#### Admin API server
The API server serves requests from the Admin UI. It is built on top of the services in both core and populate.
In development, it serves at localhost:8080


## Local development

### Prerequisites
* Java 17
* IntelliJ
* Node v16+
* Docker

### Setup

#### Database setup
run `./local-dev/run_postgres.sh start`
This will start a postgres container with a schema and user configured

#### IDE Setup
Open the root folder in IntelliJ.  Make sure intelliJ is set to Java 17.


#### Adding a new model 
1. Create the schema, models, and services
   1. Create your POJO model in `core/src/main/java/bio/terra/pearl/core/model`, you will almost certainly want to extend
   `BaseEntity`
   2. Add a liquibase changeset in `core/src/main/resources/db/changelog/changesets` to add/update any DB schema
   3. Add a DAO in `core/src/main/java/bio/terra/pearl/core/dao`.  Extending `BaseJdbiDao` will give you built-in create,
   find, and delete methods.  BaseJDBIDao makes some basic assumptions about which fields in your POJO should be persisted, and
   queried, so you may have to override those as-needed if your POJO is complex.
   4. Add a test for your DAO in `core/src/test/java/bio/terra/pearl/core/dao`  Assuming you just overrode BaseJdbiDao,
   a simple create/get/delete test should be sufficient, and will mainly serve to confirm that the database schema is correct
   5. Add a service in `core/src/test/java/bio/terra/pearl/core/service` for exposing any DAO methods, and handling
   transaction wrappers, and implementing any complex logic
   6. Add a test for any non-trivial service methods in `core/src/test/java/bio/terra/pearl/core/service`
2. Add synthetic data for your new model
   1. Add seed data in `populate/src/main/resources/seed`.  This may be either adding new files, or updating
   existing files with new objects
   2. Create a populator (or update an existing populator) in `populate/src/main/java/bio/terra/pearl/populate/service`
   In general, a separate populator should be created if the model is a standalone entity.  If it is wholly owned
   by another object, the populate logic should either be in the populator for that entity, or in the service
   3. Use the PopulateCliApp to test that the populator puts your new seed data in the database
3. Add a controller
   1. Edit `api-admin/src/main/resources/api/openapi.yml` to add a new path and endpoint configuration
   for your controller
   2. Add a controller in `api-admin/src/main/java/bio/terra/pearl/api/admin/controller` implementing the
   interface generated by the openapi yaml.
   3. visit localhost:8080 to confirm your new endpoint works.

